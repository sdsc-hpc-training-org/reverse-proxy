#!/bin/bash

## Authors: Developed by James McDougall [Github JamesMcDougallJr], Scott Sakai, 
## and Mary Thomas. The goal of this script is to start a jupyter notebook on various 
## HPC Systems by using the Reverse Proxy service. This makes a secure connection 
## between the user's local machine and the RP server.

## ====================================================================================
## Usage
##  ./start_notebook [-p <string>] [-d <string>] [-b <string>] [-t <number>]
##
##      -p: The partition your job will be started on. This can be either compute or
##          debug. Reminder that the debug queue has a max time of 30 minutes.
##
##      -d: The top level directory for your jupyter notebook. 
##          Default: /home/$USER 
##
##      -A: The Allocation (project) your notebook will be "charged" to. 
##          Default: the same as your system default. This is different for every user, 
##          but you can see your accounts using the `show_accounts` command.
##
##      -b: The batch script you want to submit. Of course the batch script needs to
##          start a jupyter notebook otherwise this script will fail.
##          Default: ./batch/batch_notebook.sh
##
##      -t: The time in MINTUES that you want the jupyter notebook to run for.
##          Default: 30 minutes
##
##
## =====================================================================================

INFO=0
start_dir=""
runtime=""
project=""
partition=""
script=""
input_runtime=""
environment=""
OPTIND=1

# Submits the a batch job which defines a jupyter notebook
# Note that behavior is undefined if you configure the script to use
# a batch script that doesn't work or submits something other than a jupyter
# notebook. Its not recommended that you change anything in this function.
function start_notebook () {

    # if the cluster is tscc or tscc-stratus, use tscc-user-content
    # otherwise use comet-user-content
    hostname=$(hostname -s) && export cluster=${hostname%-*}

    # get the Reverse proxy API_TOKEN
    api_response=$(curl -s https://manage.$cluster-user-content.sdsc.edu/getlink.cgi) 
    [[ $api_response == Oops!* ]] && echo $api_response && exit 1

    export api_token=$(echo $api_response | awk 'NF>1{printf $NF}' -)
    # removes the newline char

    # remove extra spaces before or after
    if jupyter --config-dir; then
        jup_conf_dir="$(jupyter --config-dir)/rps"
    else 
        echo "It looks like you don't have jupyter installed on your account."
        echo "To learn how to install Jupyter using Miniconda, check out this link: https://comet-notebooks-101.readthedocs.io/en/comet/prerequisites.html"
        exit 0
    fi

    # ensure the jupyter config directory exists and is accessible.
    # make a temp file there for the rps to read tokens
    mkdir -p $jup_conf_dir || (echo "Failed to create directory $jup_conf_dir" && exit 1)
    chmod 0700 $jup_conf_dir || (echo "Failed to change permissions on directory $jup_conf_dir" && exit 1)
    export config=`mktemp -p $jup_conf_dir tmp.XXXXXX.py` 

    [[ $config = "" ]] && echo "Failed to make tempfile in $jup_conf_dir" && exit 1

    # Make a random ssl token
    jupyter_token=$(openssl rand -hex 16)

    # Create the temp config file
    echo "c.NotebookApp.token = '$jupyter_token'" | cat >> "$config"
    [[ $start_dir = "" ]] && start_dir=/home/$USER/ && echo "c.NotebookApp.notebook_dir = '$start_dir'" | cat >> "$config"
    echo "c.NotebookApp.allow_origin = '*'" | cat >> "$config"
    echo "c.NotebookApp.allow_remote_access = True" | cat >> "$config"

    # Give the user their url
    export jupyter_url="https://$api_token.$cluster-user-content.sdsc.edu?token=$jupyter_token"
    echo Your notebook is here:
    echo -e "\t$jupyter_url"

    # start the batch script with the api token and the starting directory
    # Argument 1 to the batch script is the RP api token
    # Argument 2 to the batch script is the config path

    if [[ $partition = "" ]]; then
        [[ $cluster = "comet" ]] && partition="compute" || partition="interactive" && echo "Using default partition: $partition"
    fi

     [[ $runtime = "" ]] && echo "No time allotment given. Default is 30 mins" && runtime="-t 00:30:00"
    
    if [[ $INFO -eq 1 ]]; then
        echo "******************Start notebook info**********************" 
        echo "User $USER"
        echo "On cluster $cluster"
        echo "Using default project" 
        echo "Batch Script: $script"
        echo "Partition: $partition"
        echo "Tempfile: $config"
        echo "Api token: $api_token"
        echo "Jupyter token: $jupyter_token"
        echo "Runtime: $runtime"
        echo "***********************************************************"
    fi

    export start_root=$PWD
    [[ $project = "" ]] || project="-A $project"
    # if sbatch is available, submit a job using that.
    if [[ $(which sbatch 2> /dev/null) != "" ]]; then
        echo "script: $script"
        [[ "$script" = "" ]] && echo "Using ./slurm/notebook.sh" && script="./slurm/notebook.sh"
        comment="User,\n$USER,"
        sbatch --comment=$comment $runtime $project -p $partition $script
    elif [[ $(which qsub 2> /dev/null) != "" ]]; then
        [[ $script = "" ]] && echo "Using ./torque/notebook.sh" && script="./torque/notebook.sh"
	echo "runtime: ${runtime#-t **}"
	echo "project: $project"
	echo "script: $script"
        qsub -l walltime=${runtime#-t **} $project $script
    else
        echo "No queue system was found. Please use slurm or torque"
    fi
}

usage() { 
    echo "Usage: $0 [-p <string>] [-d <string>] [-A <string>] [-b <string>] [-t time] [-i]" 1>&2;
    echo -e "-p: the partition to use, debug or compute. Default is compute" 1>&2;
    echo -e "-d: the top-level directory of your jupyter notebook. Default is /home/$USER" 1>&2;
    echo -e "-A: the project allocation to be used for this notebook. Default is system default (also called project or group)" 1>&2;
    echo -e "-b: the batch script you want to submit. Only those in the batch folder are supported. Default is ./batch/batch_notebook.sh" 1>&2;
    echo "-t: the time to run the notebook. Default is 30 minutes" 1>&2;
    echo "-i: Get extra information about the job you submitted using the script" 1>&2;
}

source lib/parse_time.sh

while getopts "h?:d:A:p:b:t:i:e" opt; do
    case "$opt" in
        h|\?)
            usage 
            exit 0
            ;;
        d)  start_dir=$OPTARG ;;
        A)  project=$OPTARG   ;;
        p)  partition=$OPTARG ;;
        b)  script=$OPTARG ;;
        i)  INFO=1 ;;
        t)  input_runtime=$OPTARG 
            runtime=$(parse_time $OPTARG) 
            ;;
        *)  echo "Error: invalid optional argument $OPTARG" 
            usage 
            exit 1
            ;;
    esac
done

if [[ $partition = "debug" ]]; then
    if [[ $input_runtime -gt 30 ]]; then
        echo "Invalid runtime for debug queue. Must be less than or equal to 30 minutes"
        exit 1
    fi
fi

start_notebook
